%% Some useful variations of the document class
%%\documentclass[draft]{beamer}
%%\documentclass[handout]{beamer}
% silence hyperref warnings
\documentclass[hyperref={pdfpagelabels=false}]{beamer}
%\documentclass{beamer}
\usepackage[T1]{fontenc}
\usepackage{minted}
\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
\usepackage[autostyle]{csquotes}
\usepackage{wasysym}
\usepackage{lmodern}
\mode<presentation>{\usetheme{Copenhagen}}
\title{A Caml Light Compiler for the JVM}
\author[Hupel, Kubica, Schulze Frielinghaus, Müller, Traytel]{Lars Hupel, Marek Kubica, Stefan Schulze Frielinghaus, \\Edgar Müller, Dmitriy Traytel}
\institute{TU~München}
\date{20.~August~2010}

%% get rid of navigation symbols
%\setbeamertemplate{navigation symbols}{}
\beamertemplatenavigationsymbolsempty

\definecolor{slowest}{RGB}{255, 0, 0}
\definecolor{fastest}{RGB}{0, 255, 0}
\usemintedstyle{trac}

\begin{document}

\frame{\titlepage}

% define the logo after the title page
\logo{\includegraphics[width=1.5cm]{tun}}

\begin{frame}{Lexer}
  \begin{block}{Technisches}
    \begin{itemize}
      \item JFlex
      \item Comments: (* foo (* bar *) baz *)
      \item Identifier: foo\_bar\_42
      \item Integer literals: -0x42 ; 0b101010 ; 0o52
      \item Floating-point literals are missing
      \item Character literals: 'a' ; '\textbackslash 042'
      \item String literals: "foo" ; "bar \textbackslash 023"
      \item Keywords: some
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}{Parser}
  \begin{block}{Technisches}
    \begin{itemize}
      \item CUP2
      \item CamlLight"=Syntax
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}{Typinferenz}
  \begin{block}{Constraint based typing nach Hindley-Milner}
    \begin{itemize}
      \item ca. 700 LOC, $\approx$ 50 Tests
      \item Lambda-Kalk\"ul + \texttt{let}-Ausdr\"ucke: easy :)
      \item Unterst\"utzung von \texttt{match}, \texttt{let rec}, Records, Record-Zugriff, Tupel, Tupel-Zugriff, bin\"are/un\"are Operatoren, if-then-else
      \item Pattern-Matching f\"ur 
        \begin{itemize}
	  \item Literale
	  \item Underscore
	  \item Listen (Cons, Nil)
	  \item Tupel
	  \item Records
        \end{itemize}
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]{Typinferenz}
  \begin{block}{Beispiel: Record-Pattern-Match}
      \begin{minted}[gobble=12]{ocaml}
            let { foo = (_,(x,y)); bar = z::zs } =
                { foo = ('a',(1,2::[])); bar = [true;false;true] }
             in (x + (hd y) == 3) == z
      \end{minted}
  \end{block}
  \begin{block}{Beispiel: sum}
      \begin{minted}[gobble=12,mathescape=true]{ocaml}
            let rec foldr = fun
               f acc []    -> acc
            $|$  f acc x::xs -> f x (foldr f acc xs);;
            let rec add = fun x y -> x + y;;
            let xs = [1;2;3] in foldr add 0 xs
      \end{minted}
  \end{block}
\end{frame}

\begin{frame}[fragile]{Typinferenz}
  \begin{block}{Weiteres Beispiel}
      \begin{minted}[gobble=12]{ocaml}
            let x = 3 in let y = 4 in (x,y) + 5
      \end{minted}
  \end{block}
  \begin{alertblock}{Fehlermeldungen}
  \begin{verbatim}
Type checking failed
ERROR: Couldn't unify types: 
   TypeTuple(List(TypeInt(), TypeInt()))
   TypeInt() in expression: 
(((x),(y)))+(5)
  \end{verbatim}
  \end{alertblock}
\end{frame}

\begin{frame}{Codegenerierung: MaMa}
  \begin{block}{Übersetzung AST $\Longrightarrow$ MaMa}
    \begin{itemize}
      \item Vorgehen wie in
        \begin{center}
          \emph{[Wilhelm, Seidl - Übersetzerbau: Virtuelle Maschinen]}
        \end{center}
    \end{itemize}
  \end{block}
  \begin{block}{Erweiterungen}
    \begin{itemize}
      \item Records        
        \begin{itemize}
          \item Implementierung als namenlose Tupel
          \item Feldnamensauflösung mit Hilfe der Typinferenz
        \end{itemize}
	 \item Pattern matching mit beliebigen Patterns        
        \begin{itemize}
          \item \pause kompliziert$\ldots$
        \end{itemize}
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}{Codegenerierung: MaMa -- Pattern Matching}
  \begin{block}{Pattern Matching im AST}
  	\texttt{match} $e_0$ \texttt{with} $p_1$ \texttt{->} $e_1$ \texttt{|} $\ldots$ \texttt{|} $p_n$ \texttt{->} $e_n$
  \end{block}
  \begin{block}{Idee}
    \begin{itemize}
  	\item Generiere rekursiv sogenannten \emph{matching code} für jedes einzelne Pattern $p_i$.
  	\item Invariante: nach Ausführung des \emph{matching code} liegt auf dem Stack eine 1, falls $e_0$ $p_i$ matcht, sonst 0.
  	\item Zusammengesetzte Patterns (wie z.B. Tupel) generieren den $matching code$ rekursiv und führen $AND$-Instruktionen aus.  
  	\item Dabei wird der Code für $e_0$ nur einmal generiert.
  	\end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]{Codegenerierung: MaMa -- Fehlermeldungen}
\begin{block}{\texttt{let hd = fun x::xs -> x in hd []}}
\begin{itemize}
\item Für jedes Pattern Matching lege auf den Stack:
\begin{enumerate}
\item Den Match-Ausdruck
\item Zeilen- und Spaltenangaben
\end{enumerate}
\item Virtuelle MaMa-Maschine produziert Ausgaben von der Form:
\begin{small}
\begin{verbatim}
Exception in thread "main" java.lang.RuntimeException: 
Pattern match failure in the expression
	"match (427 @ 0) with Cons(Id(4212),Underscore) -> (4212)"
in line 1 and column 24
unlucky you!
\end{verbatim}
\end{small}
\end{itemize}
\end{block}
\end{frame}

\begin{frame}{Codegenerierung: JVM"=Bytecode}
  \begin{block}{Idee}
    \begin{itemize}
      \item Verarbeitet erweiterten MaMa"=Code: deineMaMa
        \begin{itemize}
          \item Instruktionen die PC lesen, nehmen stattdessen Label als Parameter
          \item Instruktionen die PC modifizieren, geben stattdessen Label aus
        \end{itemize}
      \item Verwendung des JVM"=Heaps
      \item Verwendung von \texttt{java.util.Stack}
      \item Instruktionen in Java geschrieben
    \end{itemize}
  \end{block}
  \begin{block}{ASM}
    \begin{itemize}
      \item Library für Bytecodeinspektion und Modifikation
      \item Wird genutzt um unsere eigene \texttt{main()} einzuschleusen
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}{Zustand}
  \begin{exampleblock}{Was funktioniert}
    \begin{itemize}
      \item Syntax, mit (sinnvollen?) Fehlermeldungen
      \item Lambdas, Match, Tupel, Records, Strings, Listen
      \item Ausgabe von Java"=Bytecode
    \end{itemize}
  \end{exampleblock}
  \begin{alertblock}{Was nicht funktioniert}
    \begin{itemize}
      \item Typkonstruktoren
      \item Seiteneffekte, Exceptions
      \item Threads
    \end{itemize}
  \end{alertblock}
\end{frame}

\begin{frame}{Benchmarks}
  \begin{block}{Ackermann(3, 5)}
    Zweifaches Pattern Matching

    \begin{tabular}{l|l|l|l}
       & Caml Light & Scala & TUM \\
      \hline
      Kompilieren & \textcolor{fastest}{$0.0s$} & \textcolor{slowest}{$9.3s$} & $4.1s$ \\
      Ausführen & \textcolor{fastest}{$0,00s$} & $1.03s$ & \textcolor{slowest}{$1.69s$} \\
    \end{tabular}
  \end{block}
  \begin{block}{Factorial(10)}
    Rekursiv

    \begin{tabular}{l|l|l|l}
       & Caml Light & Scala & TUM \\
      \hline
      Kompilieren & \textcolor{fastest}{$0.0s$} & \textcolor{slowest}{$9.1s$} & $3.9s$ \\
      Ausführen & \textcolor{fastest}{$0.00s$} & \textcolor{slowest}{$0.98s$} & $0.13s$ \\
    \end{tabular}
  \end{block}
  System: Core2~Duo @ 1.5~GHz x86\_64; OpenJDK~1.6.0\_18; Scala~2.8.0; Caml Light~0.75
\end{frame}

\begin{frame}{Spaß}
  \begin{block}{Code}
    $\approx 3.300$ LOC Scala, $\approx 650$ LOC Java, $> 250$ Commits
  \end{block}
  \begin{block}{Best of Commit"=Messages}
    \begin{itemize}
      % TODO: select best
      \item \enquote{Write the bytes in, you know, a correct way}
      \item \enquote{Whee, the machine can actually run more complicated code without failing}
      \item \enquote{Look at me mom, I made a jQuery"=like chainable DSL for generating bytecode}
      \item \enquote{Maching of tuples works but is REALLY ugly}
      \item \enquote{fixed REALLY stupid bug with CUP2/Scala layer}
      \item \enquote{Get out of the JAR, *.mama. You're not even bytecode!}
      \item \enquote{Case classes should not inherit other case classes, you know? We have so much syntactic sugar, use that instead!}
      \item \enquote{Hey ., you should really consider matching newlines, too!}
      \item \enquote{fixed \enquote{closures vs getbasic}}
      \item \enquote{Changed order of generated code instruction so that the code is actually valid}
      \item \enquote{Scala supports some mad syntactic sugar. Mad! I tell you.}
      \item \enquote{Marek goes insane and after that, realizes that bipush handles only +127 and then wraps around.}
      \item \enquote{I can haz right order of valyooz?}
      \item \enquote{I heard you want to know where exactly the typo in your souce code is. Here you are!}
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}{Rückblick}
  \begin{exampleblock}{Was war gut}
    \begin{itemize}
      \item Scala Patternmatching
      \item Betreuung \smiley
    \end{itemize}
  \end{exampleblock}
  \begin{alertblock}{Was war weniger gut}
    \begin{itemize}
      \item NetBeans
      \item Compilezeiten von \texttt{scalac}
      \item Rollo ging täglich um 14:30 rauf \frownie
    \end{itemize}
  \end{alertblock}
\end{frame}

\begin{frame}{Zukunft}
  \begin{block}{Mögliche Erweiterungen}
    \begin{itemize}
      \item Stdlib bereitstellen
      \item Verwendung des JVM"=Stacks
      \item Threads
      \item Optimierungen: TCO
    \end{itemize}
  \end{block}
\end{frame}

\end{document}
